[ { "title": "在M1上尝试编译一些工具", "url": "/posts/Build-code-on-apple-silicon/", "categories": "Machine Learning, Mathematics", "tags": "Theory of Machine Learning", "date": "2021-01-09 07:52:00 +0000", "snippet": " 本文写于2021年1月9日且内容极具时效性，如果您在阅读的时候发现有信息已经过时，可以去对应项目的官网查看最新说明。1 编译器目前，GCC仍不支持M1的编译。尽管使用Rosetta2可以，但编译出的结果仍然是x86平台的目标代码。因此唯一的选择是MacOS自带的Clang。2 Homebrew光有编译器还不行，大型C++项目通常有各种各样的依赖。而Homebrew是管理这些依赖最方便的工具之一，幸运的是，现在Homebrew已可以在M1下运行，尽管官方的更新日志仍然推荐使用Rosetta2版的Homebrew，但只要安装路径和传统的/usr/local区隔开（例如官方推荐的/opt/..." }, { "title": "随笔+书籍推荐：《实时流协议概况》", "url": "/posts/diary-and-book-realtime-steam-protocol/", "categories": "Miscellaneous, Life", "tags": "life", "date": "2019-11-12 18:47:00 +0000", "snippet": "高维几何还没有写完，又打算开新坑了（苦笑），一方面是高维几何的一些理论的编写以及研究很耗时，另一方面是近期主要的项目都和GUI相关，所以打算整理一下基础理论。另外，家里的书太多，近期打算整理下，之前很多书都是强行塞进去的，并不规整。我想考虑一下按照类别进行整理，希望不要给自己挖坑2333。另外推荐一个电子书，里面包含了现代互联网实时通信的几个主流技术基础以及相关文档的索引。可以在PubNub官网上免费下载到。" }, { "title": "深入理解GUI (一) GUI的基本理论（未完）", "url": "/posts/GUI-Introduction/", "categories": "Computers, OS", "tags": "Computer Graphics", "date": "2019-10-05 07:52:00 +0000", "snippet": "第一章 概述1 一点历史 下述历史内容基本都是从Wikipedia得来，仅供参考人机交互 ( Human–Computer Interaction ) 领域研究如何在人与计算机之间建造高效沟通的桥梁，这个桥梁就是我们现在经常听到的用户界面 ( User Interface, UI ) 。UI 无处不在，可以说，只要涉及到人机交互的设备：游戏机、手机、MP3播放器、嵌入式设备等，都需要 UI 。我们熟悉的两种 UI 分别是命令行界面 ( Command Line Interface ) 和 图形用户界面 ( Graphic User Interface ) 。命令行界面从早期的电传打字机..." }, { "title": "高维数据算法基础 (一) 高维数据的基本概念(未完)", "url": "/posts/high-dimensional-data-algorithm-1/", "categories": "Machine Learning, Mathematics", "tags": "Theory of Machine Learning", "date": "2019-10-05 07:52:00 +0000", "snippet": "1 什么是高维数据高维数据这个名词听着挺吓人的，但其实我们日常开发中不知不觉已经接触过很多了。例如我们最常用的Elastic Search搜索引擎，其核心算法就是把要搜索的文档转换成某种数据形式存储起来，在有搜索请求的时候，执行某种算法，将相关的文档尽可能的全部召唤出来，并按照相关度从高到低排序。又例如我们经常用到的商品推荐系统，大家耳熟能详的协同过滤，其实是通过一种特殊的矩阵为核心理论实现的。上面提到的某种数据形式和特殊的矩阵其实就是接下来我们要探讨的课题——高维数据。其实我们从刚进入计算机科学基础的学习时就已经频繁接触过高维数据了，C++中的vector其实就是一个典型的高维数据存储..." }, { "title": "C++模板的一些二义性语法讨论", "url": "/posts/typename-in-cplusplus-template/", "categories": "Computers, Coding", "tags": "C++ template", "date": "2019-09-13 03:38:00 +0000", "snippet": "首先大家看下面一段代码：12345678910template&amp;lt;typename T&amp;gt;std::vector&amp;lt;T&amp;gt;&amp;amp; arrayRotate(const std::vector&amp;lt;T&amp;gt;&amp;amp; src){ std::vector&amp;lt;T&amp;gt; dst(src.size()); for (std::vector&amp;lt;T&amp;gt;::iterator iter = src.begin(); src.end() != iter; iter++) { ..." }, { "title": "从一个HAVE_STRNLEN宏定义说起", "url": "/posts/function-exists-verification-for-strnlen/", "categories": "Computers, Coding", "tags": "C++", "date": "2019-09-10 13:27:00 +0000", "snippet": "最近碰到了一个奇怪的跨平台代码：12345678910111213// no strnlen on some OSes (Mac OS)#if !HAVE_STRNLENsize_t strnlen ( const char * s, size_t iMaxLen ){ if ( !s ) return 0; size_t iRes = 0; while ( *s++ &amp;amp;&amp;amp; iRes&amp;lt;iMaxLen ) ++iRes; return iRes;}#endif看注释的意思似乎是在防止某些操作系统下没有strnlen函数而设置的跨平台代码。看..." }, { "title": "博客搬家", "url": "/posts/welcome-to-jekyll/", "categories": "Miscellaneous, Life", "tags": "life", "date": "2019-09-07 09:37:55 +0000", "snippet": "搬家到新域名。投奔了Jekyll哈哈哈哈哈。本地调试可编译成html然后用Nginx做成纯静态站点部署。更轻便更省内存~大推荐~emmm审视了一下之前写的很多文都不满意，最后只留下了两篇不过今后会更多写文。也请大家多多关照啦~——爱你们的木头诶嘿~" }, { "title": "字符编码的历史", "url": "/posts/the-encoding-history/", "categories": "Computers, OS", "tags": "unicode", "date": "2018-11-06 09:37:55 +0000", "snippet": "1 ASCII其实计算机处理字符串的方法都是一样的——一串字节序列，每个字节或者每几个字节代表了现实世界里的一个字符。至于什么字节代表什么字符，就由不同的编码标准来指定了。其中最常见的就是人们耳熟能详的ASCII——由7位二进制数据表示一个字符（一个字节是8位二进制数据）。2 扩展ASCII后来，人们开始扩展ASCII，多用一位二进制数据可以用来表示128个额外的字符。当时IBM PC在1981年推出的时候，其中有一个基于ROM的256个字符组成的字符集被用在了他们的显卡里，而这个刚好就成为了IBM公司标准的一个重要组成部分。这个IBM扩展字符集被烧录在无数显卡和打印机的ROM里，被很多..." } ]
